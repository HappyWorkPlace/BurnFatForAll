<!DOCTYPE html>
<html lang="th">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Healthy Food Match ‚Äì Mobile Optimized</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Mitr:wght@400;700&display=swap" rel="stylesheet">

<style>
/* ========== RESET & BASIC LAYOUT ========== */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

html {
    font-size: 16px;
    overflow: hidden; /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£ scroll */
    height: 100vh;
    touch-action: manipulation; /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô zoom ‡πÅ‡∏•‡∏∞ scroll */
}

body {
    font-family: 'Mitr', sans-serif;
    background: #f0f4f0;
    min-height: 100vh;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
    overflow: hidden;
    color: #333;
    touch-action: manipulation;
    position: fixed;
    width: 100%;
}

.game-container {
    background: #ffffff;
    border-radius: 25px;
    padding: clamp(15px, 4vw, 25px);
    box-shadow: 0 15px 40px rgba(0, 0, 0, 0.08);
    animation: fadeIn 0.5s ease-out;
    position: relative;
    width: 100%;
    max-width: 450px;
    border: 1px solid #eef2f0;
    margin: 0 auto;
    overflow: hidden;
    touch-action: manipulation;
}

@keyframes fadeIn {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
}

/* ========== HEADER ========== */
.game-title {
    font-size: clamp(28px, 7vw, 36px);
    font-weight: 700;
    text-align: center;
    color: #4caf50;
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
}

.game-title::before {
    content: '';
    display: block;
    width: 20px;
    height: 20px;
    background-color: #4caf50;
    border-radius: 50%;
}

/* ========== STATS DISPLAY ========== */
.game-stats {
    display: flex;
    justify-content: center;
    gap: clamp(10px, 2vw, 15px);
    margin-bottom: 25px;
}

.stat-box {
    background: #4caf50;
    color: white;
    border-radius: 15px;
    padding: clamp(10px, 2vw, 15px) clamp(15px, 4vw, 25px);
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
    position: relative;
    transition: 0.3s transform, 0.3s box-shadow;
    flex: 1;
    text-align: center;
    touch-action: manipulation;
}

.stat-box:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(76, 175, 80, 0.4);
}

.stat-label {
    font-size: clamp(12px, 2.5vw, 13px);
    font-weight: 400;
    opacity: 0.9;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.stat-value {
    font-size: clamp(24px, 6vw, 32px);
    font-weight: 700;
    margin-top: 5px;
}

.multiplier-indicator {
    position: absolute;
    top: -8px;
    right: -8px;
    background: #ff9800;
    color: white;
    font-size: clamp(10px, 2vw, 12px);
    font-weight: 700;
    min-width: clamp(28px, 7vw, 35px);
    height: clamp(24px, 6vw, 28px);
    border-radius: 15px;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    transform: scale(0.5);
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    border: 2px solid white;
    padding: 0 5px;
    white-space: nowrap;
}

.multiplier-indicator.show {
    opacity: 1;
    transform: scale(1);
}

/* ========== SPECIAL CANDIES INFO ========== */
.special-candies-info {
    background: #f5f8f5;
    border-radius: 15px;
    padding: 15px;
    margin-bottom: 20px;
    text-align: center;
    border: 1px solid #e8ede8;
}

.special-candies-title {
    font-size: clamp(16px, 4vw, 18px);
    font-weight: 700;
    color: #4caf50;
    margin-bottom: 12px;
}

.special-candies-list {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
}

.special-candy-info {
    display: flex;
    gap: 8px;
    align-items: center;
    background: white;
    padding: 8px 15px;
    border-radius: 20px;
    font-size: clamp(12px, 2.5vw, 14px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

/* ========== GAME BOARD ========== */
.board {
    display: grid;
    --cell-size: min(9vw, 42px);
    grid-template-columns: repeat(8, var(--cell-size));
    grid-template-rows: repeat(8, var(--cell-size));
    gap: 3px;
    background: #e8ede8;
    padding: 6px;
    border-radius: 15px;
    margin: 0 auto;
    width: fit-content;
    max-width: calc(100vw - 40px);
    touch-action: none; /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£ scroll ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏ï‡∏∞‡∏ö‡∏≠‡∏£‡πå‡∏î */
    -webkit-touch-callout: none;
    -webkit-user-select: none;
}

.cell {
    width: var(--cell-size);
    height: var(--cell-size);
    background: #f7f9f7;
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    position: relative;
    transition: all 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    overflow: hidden;
    touch-action: none;
    -webkit-touch-callout: none;
}

.cell.hint {
    animation: hint-glow 1.2s ease-in-out infinite alternate;
}

@keyframes hint-glow {
    from { box-shadow: 0 0 15px rgba(255, 152, 0, 0.6); }
    to { box-shadow: 0 0 25px rgba(255, 152, 0, 1), 0 0 35px rgba(255, 152, 0, 0.5); }
}

/* ========== CANDY STYLING ========== */
.candy {
    font-size: min(7vw, 30px);
    filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.15));
    user-select: none;
    transition: all 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    will-change: transform;
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    pointer-events: none; /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô interference ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á events */
}

.candy.new {
    animation: popIn 0.25s ease-out;
}

@keyframes popIn {
    from { transform: scale(0.5); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

.candy.dragging {
    position: fixed;
    transform: scale(1.2);
    filter: drop-shadow(0 12px 35px rgba(0, 0, 0, 0.3));
    touch-action: none;
    transition: none;
    z-index: 9999;
    pointer-events: none;
}

.candy.falling {
    animation: fall 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

@keyframes fall {
    from { transform: translateY(-100px) scale(0.8); opacity: 0.7; }
    to { transform: translateY(0) scale(1); opacity: 1; }
}

.candy.matched {
    animation: spinAndFade 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards;
}

@keyframes spinAndFade {
    0% { transform: scale(1.1) rotate(0deg); opacity: 1; }
    50% { transform: scale(1.3) rotate(90deg); opacity: 0.7; }
    100% { transform: scale(0) rotate(180deg); opacity: 0; }
}

/* ========== CONTROL BUTTONS ========== */
.game-controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 25px;
}

.btn {
    padding: 12px 25px;
    font-size: clamp(16px, 3.5vw, 18px);
    font-weight: 700;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    letter-spacing: 1px;
    transition: 0.3s transform, 0.3s box-shadow;
    text-transform: uppercase;
    touch-action: manipulation;
}

.btn-primary {
    background: #4caf50;
    color: white;
    box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
}

.btn-secondary {
    background: #ff9800;
    color: white;
    box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
}

.btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.2);
}

.btn:active {
    transform: translateY(0);
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
}

/* ========== GAME OVER OVERLAY ========== */
.game-over-overlay {
    position: fixed;
    inset: 0;
    display: none;
    justify-content: center;
    align-items: center;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(5px);
    z-index: 1000;
    touch-action: manipulation;
}

.game-over-content {
    background: white;
    padding: clamp(30px, 6vw, 50px);
    border-radius: 25px;
    text-align: center;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.2);
    animation: slideIn 0.5s ease-out;
    width: 90%;
    max-width: 450px;
}

@keyframes slideIn {
    from { transform: translateY(-50px) scale(0.9); opacity: 0; }
    to { transform: translateY(0) scale(1); opacity: 1; }
}

.game-over-title {
    font-size: clamp(36px, 8vw, 48px);
    font-weight: 700;
    color: #4caf50;
    margin-bottom: 30px;
}

.final-stats {
    font-size: clamp(18px, 4vw, 22px);
    line-height: 1.8;
    margin-bottom: 30px;
}

.final-stats strong {
    color: #4caf50;
}

.high-score {
    font-size: clamp(16px, 3.5vw, 18px);
    color: #ff9800;
    margin-bottom: 25px;
}
</style>
</head>
<body>

<div class="game-container">
    <h1 class="game-title">Healthy Food Match</h1>

    <div class="game-stats">
        <div class="stat-box">
            <div class="stat-label">Score</div>
            <div class="stat-value" id="score">0</div>
            <div class="multiplier-indicator" id="multiplier">2x</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Moves Left</div>
            <div class="stat-value" id="moves">30</div>
        </div>
        <div class="stat-box">
            <div class="stat-label">Chain</div>
            <div class="stat-value" id="chain">0</div>
        </div>
    </div>

    <div class="special-candies-info">
        <div class="special-candies-title">üåü ‡∏£‡∏∞‡∏ö‡∏ö‡∏Ñ‡∏π‡∏ì‡∏™‡∏∞‡∏™‡∏° üåü</div>
        <div class="special-candies-list">
            <div class="special-candy-info">4+ ‡∏ä‡∏¥‡πâ‡∏ô/L/T ‚û°Ô∏è ‚ö°Ô∏è ‡∏Ñ‡∏π‡∏ì+1 (‡∏Ñ‡∏á 2 ‡∏ï‡∏≤)</div>
            <div class="special-candy-info">‡∏†‡∏≤‡∏¢‡πÉ‡∏ô 2 ‡∏ï‡∏≤ ‚û°Ô∏è üéØ ‡∏™‡∏∞‡∏™‡∏°‡∏Ñ‡∏π‡∏ì‡∏ï‡πà‡∏≠‡πÑ‡∏î‡πâ</div>
        </div>
    </div>

    <div class="board" id="board"></div>
    
    <div class="game-controls">
        <button class="btn btn-primary" onclick="game.startNewGame()">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà</button>
        <button class="btn btn-secondary" onclick="game.showHint()">‡∏Ñ‡∏≥‡πÉ‡∏ö‡πâ üí°</button>
    </div>
</div>

<div class="game-over-overlay" id="gameOverOverlay">
    <div class="game-over-content">
        <h2 class="game-over-title">‡∏à‡∏ö‡πÄ‡∏Å‡∏°!</h2>
        <div class="final-stats">
            <strong>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢:</strong> <span id="finalScore">0</span><br>
            <strong>‡∏Ñ‡∏≠‡∏°‡πÇ‡∏ö‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î:</strong> <span id="maxCombo">0</span>x<br>
            <strong>‡∏ï‡∏±‡∏ß‡∏Ñ‡∏π‡∏ì‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î:</strong> <span id="maxMultiplierStat">0</span>x
        </div>
        <div class="high-score" id="highScoreText"></div>
        <button class="btn btn-primary" onclick="game.startNewGame()">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
    </div>
</div>

<script>
class HealthyFoodMatch {
    constructor() {
        // ========== GAME CONFIGURATION ==========
        this.BOARD_SIZE = 8;
        this.INITIAL_MOVES = 30;
        this.MIN_MATCH_LENGTH = 3;
        this.BASE_POINTS_PER_CANDY = 4;
        this.TOUCH_THRESHOLD = 30; // ‡πÄ‡∏û‡∏¥‡πà‡∏° threshold ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö touch
        
        // ========== FOOD TYPES ==========
        this.foodTypes = ['ü•ï', 'üçá', 'ü•¶', 'ü•í', 'üçé', 'üçä'];
        
        // ========== GAME STATE ==========
        this.gameBoard = [];
        this.currentScore = 0;
        this.remainingMoves = this.INITIAL_MOVES;
        this.currentChain = 0;
        this.maxChainCombo = 0;
        this.isGameProcessing = false;
        
        // ========== MULTIPLIER SYSTEM ==========
        this.scoreMultiplier = 1;
        this.maxMultiplier = 1;
        this.multiplierTurnsLeft = 0;
        
        // ========== DRAG STATE ==========
        this.dragState = {
            isDragging: false,
            startCell: null,
            dragElement: null,
            startPosition: null,
            dragOffset: null,
            touchStartTime: 0
        };
        
        // ========== HIGH SCORE ==========
        this.highScore = parseInt(localStorage.getItem('healthyFoodMatchHighScore')) || 0;
        
        // ========== HINT STATE ==========
        this.hintTimeout = null;
        
        // ========== DOM ELEMENTS ==========
        this.initializeDOMElements();
        
        // ========== EVENT LISTENERS ==========
        this.setupEventListeners();
        
        // ========== START GAME ==========
        this.initializeGame();
    }

    // ========== INITIALIZATION METHODS ==========
    
    initializeDOMElements() {
        this.elements = {
            board: document.getElementById('board'),
            score: document.getElementById('score'),
            moves: document.getElementById('moves'),
            chain: document.getElementById('chain'),
            multiplier: document.getElementById('multiplier'),
            gameOverOverlay: document.getElementById('gameOverOverlay'),
            finalScore: document.getElementById('finalScore'),
            maxCombo: document.getElementById('maxCombo'),
            maxMultiplierStat: document.getElementById('maxMultiplierStat'),
            highScoreText: document.getElementById('highScoreText')
        };
    }

    setupEventListeners() {
        // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£ scroll ‡∏Ç‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤‡πÄ‡∏ß‡πá‡∏ö
        document.addEventListener('touchmove', (e) => {
            if (this.dragState.isDragging) {
                e.preventDefault();
            }
        }, { passive: false });

        document.addEventListener('touchstart', (e) => {
            if (this.dragState.isDragging) {
                e.preventDefault();
            }
        }, { passive: false });

        // Event listeners ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö drag
        window.addEventListener('pointermove', (e) => this.handleDragMove(e), { passive: false });
        window.addEventListener('pointerup', (e) => this.handleDragEnd(e), { passive: false });
        window.addEventListener('touchend', (e) => this.handleDragEnd(e), { passive: false });
    }

    initializeGame() {
        this.isGameProcessing = true;
        this.resetGameState();
        this.createGameBoard();
        this.createBoardDisplay();
        
        while (!this.hasPossibleMoves()) {
            this.createGameBoard();
        }
        
        this.renderAllCells();
        this.updateGameUI();
        this.isGameProcessing = false;
    }

    resetGameState() {
        this.currentScore = 0;
        this.remainingMoves = this.INITIAL_MOVES;
        this.currentChain = 0;
        this.maxChainCombo = 0;
        this.scoreMultiplier = 1;
        this.maxMultiplier = 1;
        this.multiplierTurnsLeft = 0;
        this.gameBoard = [];
        this.clearHint();
        this.elements.gameOverOverlay.style.display = 'none';
        
        if (this.elements) {
            this.updateMultiplierDisplay();
        }
    }

    // ========== BOARD CREATION METHODS ==========

    createGameBoard() {
        this.gameBoard = [];
        for (let r = 0; r < this.BOARD_SIZE; r++) {
            this.gameBoard[r] = [];
            for (let c = 0; c < this.BOARD_SIZE; c++) {
                let food;
                do {
                    food = this.getRandomFood();
                } while (
                    (c >= 2 && this.gameBoard[r][c-1] === food && this.gameBoard[r][c-2] === food) ||
                    (r >= 2 && this.gameBoard[r-1][c] === food && this.gameBoard[r-2][c] === food)
                );
                this.gameBoard[r][c] = food;
            }
        }
    }

    createBoardDisplay() {
        this.elements.board.innerHTML = '';
        for (let r = 0; r < this.BOARD_SIZE; r++) {
            for (let c = 0; c < this.BOARD_SIZE; c++) {
                const cell = this.createCellElement(r, c);
                this.elements.board.appendChild(cell);
            }
        }
    }

    createCellElement(row, col) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.row = row;
        cell.dataset.col = col;
        
        // ‡πÉ‡∏ä‡πâ touchstart ‡πÅ‡∏ó‡∏ô pointerdown ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö mobile
        cell.addEventListener('touchstart', (e) => this.handleDragStart(e, row, col), { passive: false });
        cell.addEventListener('pointerdown', (e) => this.handleDragStart(e, row, col), { passive: false });
        
        return cell;
    }

    // ========== RENDERING METHODS ==========

    renderAllCells() {
        for (let r = 0; r < this.BOARD_SIZE; r++) {
            for (let c = 0; c < this.BOARD_SIZE; c++) {
                this.renderCell(r, c);
            }
        }
    }

    renderCell(row, col, options = {}) {
        const cell = this.getCellElement(row, col);
        if (!cell) return;
        
        cell.innerHTML = '';
        const food = this.gameBoard[row][col];
        if (!food) return;
        
        const foodElement = document.createElement('span');
        foodElement.className = 'candy';
        foodElement.textContent = food;
        
        if (options.isFalling) {
            foodElement.classList.add('falling');
        } else if (options.isNew) {
            foodElement.classList.add('new');
        }
        
        cell.appendChild(foodElement);
    }

    updateGameUI() {
        // Smooth score animation
        if (this.elements.score.textContent !== this.currentScore.toString()) {
            this.elements.score.style.transform = 'scale(1.1)';
            this.elements.score.style.transition = 'all 0.2s ease';
            setTimeout(() => {
                this.elements.score.textContent = this.currentScore;
                this.elements.score.style.transform = 'scale(1)';
            }, 100);
        }
        
        this.elements.moves.textContent = this.remainingMoves;
        this.elements.chain.textContent = this.currentChain;
    }

    updateMultiplierDisplay() {
        if (!this.elements.multiplier) return;
        if (this.scoreMultiplier > 1 && this.multiplierTurnsLeft > 0) {
            this.elements.multiplier.textContent = `${this.scoreMultiplier}x (${this.multiplierTurnsLeft})`;
            this.elements.multiplier.classList.add('show');
        } else {
            this.elements.multiplier.classList.remove('show');
        }
    }

    // ========== DRAG HANDLING METHODS ==========

    handleDragStart(event, row, col) {
        if (this.isGameProcessing || this.remainingMoves <= 0 || this.dragState.isDragging) return;
        
        event.preventDefault();
        event.stopPropagation();
        this.clearHint();
        
        const cell = this.getCellElement(row, col);
        const foodElement = cell.querySelector('.candy');
        if (!foodElement) return;

        const rect = foodElement.getBoundingClientRect();
        const eventPos = this.getEventPosition(event);
        
        this.dragState = {
            isDragging: true,
            startCell: { row, col },
            dragElement: foodElement.cloneNode(true), // ‡∏™‡∏£‡πâ‡∏≤‡∏á copy ‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏¢‡πâ‡∏≤‡∏¢ element ‡∏à‡∏£‡∏¥‡∏á
            startPosition: eventPos,
            dragOffset: { 
                x: eventPos.x - rect.left - rect.width/2, 
                y: eventPos.y - rect.top - rect.height/2 
            },
            touchStartTime: Date.now()
        };
        
        // ‡∏™‡∏£‡πâ‡∏≤‡∏á drag element ‡πÉ‡∏´‡∏°‡πà‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°
        this.dragState.dragElement.className = 'candy dragging';
        this.dragState.dragElement.style.position = 'fixed';
        this.dragState.dragElement.style.zIndex = '9999';
        this.dragState.dragElement.style.pointerEvents = 'none';
        
        document.body.appendChild(this.dragState.dragElement);
        this.handleDragMove(event);
    }

    handleDragMove(event) {
        if (!this.dragState.isDragging) return;
        event.preventDefault();
        event.stopPropagation();
        
        const currentPosition = this.getEventPosition(event);
        const x = currentPosition.x - this.dragState.dragOffset.x;
        const y = currentPosition.y - this.dragState.dragOffset.y;
        
        this.dragState.dragElement.style.left = `${x}px`;
        this.dragState.dragElement.style.top = `${y}px`;
    }

    handleDragEnd(event) {
        if (!this.dragState.isDragging) return;
        
        event.preventDefault();
        event.stopPropagation();
        
        const { dragElement, startCell, touchStartTime } = this.dragState;
        
        // ‡∏•‡∏ö drag element
        if (dragElement && dragElement.parentNode) {
            document.body.removeChild(dragElement);
        }
        
        const currentPosition = this.getEventPosition(event);
        const deltaX = currentPosition.x - this.dragState.startPosition.x;
        const deltaY = currentPosition.y - this.dragState.startPosition.y;
        const dragDuration = Date.now() - touchStartTime;
        
        // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£ tap ‡∏™‡∏±‡πâ‡∏ô‡πÜ ‡∏´‡∏£‡∏∑‡∏≠ drag ‡∏à‡∏£‡∏¥‡∏á
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        
        if (distance > this.TOUCH_THRESHOLD && dragDuration > 100) {
            const targetCell = this.calculateTargetCell(deltaX, deltaY);
            
            if (targetCell && this.isValidCell(targetCell.row, targetCell.col)) {
                this.attemptSwap(startCell.row, startCell.col, targetCell.row, targetCell.col);
            }
        }
        
        this.dragState = { 
            isDragging: false, 
            startCell: null, 
            dragElement: null, 
            startPosition: null,
            touchStartTime: 0
        };
    }

    getEventPosition(event) {
        const pointer = event.touches ? event.touches[0] : event;
        return { x: pointer.clientX, y: pointer.clientY };
    }

    calculateTargetCell(deltaX, deltaY) {
        if (Math.abs(deltaX) < this.TOUCH_THRESHOLD && Math.abs(deltaY) < this.TOUCH_THRESHOLD) return null;
        
        let { row, col } = this.dragState.startCell;
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            col += deltaX > 0 ? 1 : -1;
        } else {
            row += deltaY > 0 ? 1 : -1;
        }
        return { row, col };
    }

    // ========== SWAP LOGIC METHODS ==========

    async attemptSwap(row1, col1, row2, col2) {
        if (this.isGameProcessing) return;
        
        this.isGameProcessing = true;
        await this.executeSwap(row1, col1, row2, col2);
        
        const matches = this.findAllMatches();
        
        if (matches.length > 0) {
            this.remainingMoves--;
            this.updateGameUI();
            await this.processMatches(matches);
            this.handleMultiplierTurns();
        } else {
            await this.executeSwap(row1, col1, row2, col2); // Swap back
        }
        
        this.isGameProcessing = false;
        
        setTimeout(() => {
            if (this.remainingMoves <= 0 && !this.isGameProcessing) {
                this.showGameOver();
            }
        }, 100);
    }

    async executeSwap(row1, col1, row2, col2) {
        this.swapFoodsInModel(row1, col1, row2, col2);
        
        // Smooth swap animation
        const cell1 = this.getCellElement(row1, col1);
        const cell2 = this.getCellElement(row2, col2);
        const candy1 = cell1?.querySelector('.candy');
        const candy2 = cell2?.querySelector('.candy');
        
        if (candy1) {
            candy1.style.transform = 'scale(1.1)';
            candy1.style.transition = 'all 0.15s ease';
        }
        if (candy2) {
            candy2.style.transform = 'scale(1.1)';
            candy2.style.transition = 'all 0.15s ease';
        }
        
        await this.delay(75);
        
        this.renderCell(row1, col1, { isNew: true });
        this.renderCell(row2, col2, { isNew: true });
        
        await this.delay(75);
    }

    swapFoodsInModel(row1, col1, row2, col2) {
        [this.gameBoard[row1][col1], this.gameBoard[row2][col2]] = [this.gameBoard[row2][col2], this.gameBoard[row1][col1]];
    }

    // ========== MULTIPLIER METHODS ==========

    handleMultiplierTurns() {
        if (this.multiplierTurnsLeft > 0) {
            this.multiplierTurnsLeft--;
            
            if (this.multiplierTurnsLeft <= 0) {
                this.scoreMultiplier = 1;
                this.multiplierTurnsLeft = 0;
            }
            
            this.updateMultiplierDisplay();
            this.updateGameUI();
        }
    }

    // ========== MATCH PROCESSING METHODS ==========

    async processMatches(initialMatches) {
        this.currentChain = 0;
        let matches = initialMatches;
        let hasSpecialMatchInThisTurn = false;
        
        while (matches.length > 0) {
            this.isGameProcessing = true;
            this.currentChain++;
            if (this.currentChain > this.maxChainCombo) this.maxChainCombo = this.currentChain;
            
            const specialMatch = this.checkForSpecialMatches(matches);
            if (specialMatch) {
                hasSpecialMatchInThisTurn = true;
            }
            
            const clearedCells = this.markMatchedFoods(matches);
            this.addScore(clearedCells.size, this.currentChain, this.scoreMultiplier);
            
            this.updateGameUI();
            
            await this.delay(500);
            
            this.removeMatchedFoods(clearedCells);
            
            await this.applyGravitySmooth();
            await this.fillEmptyCellsSmooth();
            
            matches = this.findAllMatches();
        }
        
        if (hasSpecialMatchInThisTurn) {
            this.updateMultiplierFromSpecialMatches();
        }
        
        if (!this.hasPossibleMoves()) await this.shuffleBoard();
        this.isGameProcessing = false;
    }

    checkForSpecialMatches(matches) {
        for (const match of matches) {
            let type = this.getMatchType(match.cells.length);
            if(match.type === 'L_T_shape') type = 'L_T_shape';

            if (type === 'L_T_shape' || type === 'five_match' || type === 'four_match') {
                return true;
            }
        }
        return false;
    }

    updateMultiplierFromSpecialMatches() {
        if (this.scoreMultiplier === 1) {
            this.scoreMultiplier = 2;
        } else {
            this.scoreMultiplier += 1;
        }
        
        this.multiplierTurnsLeft = 2;
        
        if (this.scoreMultiplier > this.maxMultiplier) {
            this.maxMultiplier = this.scoreMultiplier;
        }
        
        this.updateMultiplierDisplay();
    }

    markMatchedFoods(matches) {
        const cellsToClr = new Set();
        matches.forEach(match => match.cells.forEach(cell => cellsToClr.add(`${cell.row},${cell.col}`)));
        
        cellsToClr.forEach(cellKey => {
            const [row, col] = cellKey.split(',').map(Number);
            const cellEl = this.getCellElement(row, col);
            const candyEl = cellEl?.querySelector('.candy');
            if(candyEl) candyEl.classList.add('matched');
        });
        
        return cellsToClr;
    }

    removeMatchedFoods(cellsToClr) {
        cellsToClr.forEach(cellKey => {
            const [row, col] = cellKey.split(',').map(Number);
            this.gameBoard[row][col] = null;
            const cellEl = this.getCellElement(row, col);
            if(cellEl) cellEl.innerHTML = '';
        });
    }

    addScore(cellCount, chain, multiplier) {
        const score = cellCount * this.BASE_POINTS_PER_CANDY * (1 + (chain - 1) * 0.5) * multiplier;
        this.currentScore += Math.round(score);
    }

    async applyGravitySmooth() {
        let hasChanges = false;
        
        for (let c = 0; c < this.BOARD_SIZE; c++) {
            let writeRow = this.BOARD_SIZE - 1;
            for (let r = this.BOARD_SIZE - 1; r >= 0; r--) {
                if (this.gameBoard[r][c]) {
                    if (r !== writeRow) {
                        hasChanges = true;
                        this.gameBoard[writeRow][c] = this.gameBoard[r][c];
                        this.gameBoard[r][c] = null;
                        
                        const fromCell = this.getCellElement(r, c);
                        const toCell = this.getCellElement(writeRow, c);
                        
                        if (fromCell && toCell) {
                            fromCell.innerHTML = '';
                            toCell.innerHTML = '';
                            
                            const newCandy = document.createElement('span');
                            newCandy.className = 'candy falling';
                            newCandy.textContent = this.gameBoard[writeRow][c];
                            toCell.appendChild(newCandy);
                        }
                    }
                    writeRow--;
                }
            }
        }
        
        if(hasChanges) await this.delay(200);
    }

    async fillEmptyCellsSmooth() {
        let needsFalling = false;
        const newCandies = [];
        
        for (let r = 0; r < this.BOARD_SIZE; r++) {
            for (let c = 0; c < this.BOARD_SIZE; c++) {
                if (!this.gameBoard[r][c]) {
                    needsFalling = true;
                    this.gameBoard[r][c] = this.getRandomFood();
                    newCandies.push({row: r, col: c});
                }
            }
        }
        
        newCandies.forEach((pos, index) => {
            setTimeout(() => {
                this.renderCell(pos.row, pos.col, { isFalling: true });
            }, index * 30);
        });
        
        if(needsFalling) await this.delay(300);
    }

    // ========== MATCH DETECTION METHODS ==========

    findAllMatches() {
        const horizontalMatches = this.findMatchesInDirection('horizontal');
        const verticalMatches = this.findMatchesInDirection('vertical');
        const combined = [...horizontalMatches, ...verticalMatches];
        const mergedMatches = [];

        while(combined.length > 0){
            let baseMatch = combined.shift();
            let wasMerged = false;
            for(let i = 0; i < mergedMatches.length; i++){
                const merged = mergedMatches[i];
                if(baseMatch.cells.some(c1 => merged.cells.some(c2 => c1.row === c2.row && c1.col === c2.col))){
                    const newCells = [...merged.cells];
                    baseMatch.cells.forEach(c1 => {
                        if(!newCells.some(c2 => c1.row === c2.row && c1.col === c2.col)){
                            newCells.push(c1);
                        }
                    });
                    mergedMatches[i] = { cells: newCells, type: 'L_T_shape' };
                    wasMerged = true;
                    break;
                }
            }
            if(!wasMerged) mergedMatches.push(baseMatch);
        }
        return mergedMatches;
    }

    findMatchesInDirection(direction) {
        const matches = [];
        const mainAxis = this.BOARD_SIZE;
        const crossAxis = this.BOARD_SIZE;

        for (let i = 0; i < mainAxis; i++) {
            let run = [];
            for (let j = 0; j < crossAxis; j++) {
                const row = direction === 'vertical' ? j : i;
                const col = direction === 'vertical' ? i : j;
                const lastRow = direction === 'vertical' ? j - 1 : i;
                const lastCol = direction === 'vertical' ? i : j - 1;
                
                if (j > 0 && this.gameBoard[row][col] === this.gameBoard[lastRow][lastCol] && this.gameBoard[row][col]) {
                    run.push({ row, col });
                } else {
                    if (run.length >= this.MIN_MATCH_LENGTH) matches.push({ cells: run, type: this.getMatchType(run.length) });
                    run = [{ row, col }];
                }
            }
            if (run.length >= this.MIN_MATCH_LENGTH) matches.push({ cells: run, type: this.getMatchType(run.length) });
        }
        return matches;
    }

    getMatchType(length) {
        if (length >= 5) return 'five_match';
        if (length === 4) return 'four_match';
        return 'normal_match';
    }

    // ========== HINT SYSTEM METHODS ==========

    showHint() {
        if (this.isGameProcessing) return;
        this.clearHint();
        const hint = this.findFirstPossibleMove();
        if (hint) {
            hint.cells.forEach(c => this.getCellElement(c.row, c.col)?.classList.add('hint'));
            this.hintTimeout = setTimeout(() => this.clearHint(), 2000);
        }
    }

    findFirstPossibleMove() {
        for (let r = 0; r < this.BOARD_SIZE; r++) {
            for (let c = 0; c < this.BOARD_SIZE; c++) {
                if (c < this.BOARD_SIZE - 1) {
                    this.swapFoodsInModel(r, c, r, c + 1);
                    const matches = this.findAllMatches();
                    this.swapFoodsInModel(r, c, r, c + 1);
                    if (matches.length > 0) return { cells: [{row: r, col: c}, {row: r, col: c+1}] };
                }
                if (r < this.BOARD_SIZE - 1) {
                    this.swapFoodsInModel(r, c, r + 1, c);
                    const matches = this.findAllMatches();
                    this.swapFoodsInModel(r, c, r + 1, c);
                    if (matches.length > 0) return { cells: [{row: r, col: c}, {row: r+1, col: c}] };
                }
            }
        }
        return null;
    }

    clearHint() {
        if (this.hintTimeout) clearTimeout(this.hintTimeout);
        document.querySelectorAll('.hint').forEach(el => el.classList.remove('hint'));
    }

    hasPossibleMoves() {
        return !!this.findFirstPossibleMove();
    }

    // ========== BOARD SHUFFLING METHODS ==========

    async shuffleBoard() {
        this.isGameProcessing = true;
        console.log("No possible moves. Shuffling board...");
        let attempts = 0;
        do {
            this.randomizeBoard();
            attempts++;
        } while ((this.findAllMatches().length > 0 || !this.hasPossibleMoves()) && attempts < 20);
        
        if (attempts >= 20) {
            this.initializeGame();
            return;
        }
        
        for (let r = 0; r < this.BOARD_SIZE; r++) {
            for (let c = 0; c < this.BOARD_SIZE; c++) {
                setTimeout(() => {
                    this.renderCell(r, c, { isFalling: true });
                }, (r * this.BOARD_SIZE + c) * 15);
            }
        }
        
        await this.delay(400);
        this.isGameProcessing = false;
    }

    randomizeBoard() {
        const allFoods = this.gameBoard.flat();
        for (let i = allFoods.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [allFoods[i], allFoods[j]] = [allFoods[j], allFoods[i]];
        }
        for (let i = 0; i < allFoods.length; i++) {
            this.gameBoard[Math.floor(i / this.BOARD_SIZE)][i % this.BOARD_SIZE] = allFoods[i];
        }
    }

    // ========== GAME OVER METHODS ==========

    showGameOver() {
        this.isGameProcessing = true;
        this.elements.finalScore.textContent = this.currentScore;
        this.elements.maxCombo.textContent = this.maxChainCombo;
        this.elements.maxMultiplierStat.textContent = `${this.maxMultiplier}x`;
        this.updateHighScore();
        this.elements.gameOverOverlay.style.display = 'flex';
    }

    updateHighScore() {
        if (this.currentScore > this.highScore) {
            this.highScore = this.currentScore;
            localStorage.setItem('healthyFoodMatchHighScore', this.highScore);
            this.elements.highScoreText.textContent = 'üéâ ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÉ‡∏´‡∏°‡πà! üéâ';
        } else {
            this.elements.highScoreText.textContent = `‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: ${this.highScore}`;
        }
    }

    // ========== PUBLIC INTERFACE METHODS ==========

    startNewGame() {
        this.elements.gameOverOverlay.style.display = 'none';
        this.initializeGame();
    }

    // ========== UTILITY METHODS ==========

    getRandomFood() {
        return this.foodTypes[Math.floor(Math.random() * this.foodTypes.length)];
    }

    getCellElement(row, col) {
        return this.elements.board.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    }

    isValidCell(row, col) {
        return row >= 0 && row < this.BOARD_SIZE && col >= 0 && col < this.BOARD_SIZE;
    }

    delay(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    }
}

// ========== GAME INITIALIZATION ==========
window.addEventListener('DOMContentLoaded', () => {
    window.game = new HealthyFoodMatch();
});
</script>
</body>
</html>
