<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Healthy Food Match - Super Stable Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.5s ease-out;
            position: relative;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        .screen-shake {
            animation: screen-shake 0.5s ease-in-out;
        }

        @keyframes screen-shake {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-5px) rotate(-1deg); }
            20% { transform: translateX(5px) rotate(1deg); }
            30% { transform: translateX(-3px) rotate(-1deg); }
            40% { transform: translateX(3px) rotate(1deg); }
            50% { transform: translateX(-2px); }
            60% { transform: translateX(2px); }
        }

        .game-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .game-title {
            font-size: 42px;
            font-weight: bold;
            background: linear-gradient(45deg, #56ab2f, #a8e063);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 15px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .game-stats {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 20px;
        }

        .stat-box {
            background: linear-gradient(135deg, #56ab2f, #a8e063);
            color: white;
            padding: 15px 30px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.2s;
            position: relative;
        }

        .stat-box:hover {
            transform: translateY(-2px);
        }

        .stat-label {
            font-size: 14px;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            font-size: 32px;
            font-weight: bold;
            margin-top: 5px;
        }

        .multiplier-indicator {
            position: absolute;
            top: -10px;
            right: -10px;
            background: rgba(243, 156, 18, 1);
            color: white;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            opacity: 0;
            transition: all 0.3s;
        }

        .multiplier-indicator.show {
            opacity: 1;
            animation: multiplier-pulse 0.5s ease-out;
        }

        @keyframes multiplier-pulse {
            0% { transform: scale(0.5); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .special-candies-info {
            background: rgba(0,0,0,0.05);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        .special-candies-title {
            font-size: 18px;
            font-weight: bold;
            color: #56ab2f;
            margin-bottom: 10px;
        }

        .special-candies-list {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .special-candy-info {
            display: flex;
            align-items: center;
            gap: 8px;
            background: white;
            padding: 8px 15px;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            font-size: 14px;
        }

        .board-container {
            position: relative;
            display: inline-block;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 65px);
            grid-template-rows: repeat(8, 65px);
            gap: 5px;
            background: rgba(0,0,0,0.1);
            padding: 10px;
            border-radius: 10px;
            position: relative;
            margin: 0 auto;
        }

        .cell {
            width: 65px;
            height: 65px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .cell.selected {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(255, 255, 255, 1);
            animation: pulse 0.5s infinite alternate;
            z-index: 10;
        }

        .cell.processing {
            pointer-events: none;
        }

        @keyframes pulse {
            from { box-shadow: 0 0 25px rgba(255, 255, 255, 1); }
            to { box-shadow: 0 0 35px rgba(255, 255, 255, 1), 0 0 45px rgba(86, 171, 47, 0.8); }
        }

        .candy {
            font-size: 40px;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 10;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
            position: relative;
            user-select: none;
        }

        .candy.falling {
            animation: fall 0.4s ease-in;
        }

        @keyframes fall {
            from { transform: translateY(-400px) rotate(180deg); opacity: 0; }
            to { transform: translateY(0) rotate(0deg); opacity: 1; }
        }

        .candy.matched {
            animation: explode 0.5s ease-out forwards;
        }

        @keyframes explode {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.5) rotate(180deg); filter: brightness(2); }
            100% { transform: scale(0) rotate(360deg); opacity: 0; }
        }

        .candy.striped-h::after {
            content: '';
            position: absolute;
            top: 50%;
            left: -10px;
            right: -10px;
            height: 3px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,1), transparent);
            transform: translateY(-50%);
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
            animation: stripe-glow-h 1s ease-in-out infinite;
        }

        .candy.striped-v::after {
            content: '';
            position: absolute;
            left: 50%;
            top: -10px;
            bottom: -10px;
            width: 3px;
            background: linear-gradient(0deg, transparent, rgba(255,255,255,1), transparent);
            transform: translateX(-50%);
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
            animation: stripe-glow-v 1s ease-in-out infinite;
        }

        @keyframes stripe-glow-h {
            0%, 100% { opacity: 0.5; transform: translateY(-50%) scaleY(1); }
            50% { opacity: 1; transform: translateY(-50%) scaleY(1.5); }
        }

        @keyframes stripe-glow-v {
            0%, 100% { opacity: 0.5; transform: translateX(-50%) scaleX(1); }
            50% { opacity: 1; transform: translateX(-50%) scaleX(1.5); }
        }

        .candy.wrapped {
            animation: wrapped-spin 2s linear infinite;
        }

        @keyframes wrapped-spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .candy.wrapped::before {
            content: 'üéÅ';
            position: absolute;
            font-size: 16px;
            top: -8px;
            right: -8px;
            animation: gift-bounce 0.5s ease-in-out infinite alternate;
        }

        @keyframes gift-bounce {
            from { transform: scale(0.8) translateY(0); }
            to { transform: scale(1.2) translateY(-3px); }
        }

        .candy.color-bomb {
            font-size: 45px;
            animation: rainbow-spin 2s linear infinite;
            filter: drop-shadow(0 0 15px rgba(255,255,255,1));
        }

        @keyframes rainbow-spin {
            0% { 
                transform: rotate(0deg); 
                filter: hue-rotate(0deg) drop-shadow(0 0 15px rgba(255,0,0,1));
            }
            25% { 
                filter: hue-rotate(90deg) drop-shadow(0 0 15px rgba(255,255,0,1));
            }
            50% { 
                transform: rotate(180deg); 
                filter: hue-rotate(180deg) drop-shadow(0 0 15px rgba(0,255,0,1));
            }
            75% { 
                filter: hue-rotate(270deg) drop-shadow(0 0 15px rgba(0,255,255,1));
            }
            100% { 
                transform: rotate(360deg); 
                filter: hue-rotate(360deg) drop-shadow(0 0 15px rgba(255,0,255,1));
            }
        }

        .special-effect {
            position: absolute;
            pointer-events: none;
            z-index: 100;
        }

        .line-clear-h {
            height: 65px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,1), transparent);
            animation: sweep-h 0.5s ease-out forwards;
            box-shadow: 0 0 20px rgba(255,255,255,0.8);
        }

        @keyframes sweep-h {
            from { width: 0; left: 50%; }
            to { width: 120%; left: -10%; }
        }

        .line-clear-v {
            width: 65px;
            background: linear-gradient(0deg, transparent, rgba(255,255,255,1), transparent);
            animation: sweep-v 0.5s ease-out forwards;
            box-shadow: 0 0 20px rgba(255,255,255,0.8);
        }

        @keyframes sweep-v {
            from { height: 0; top: 50%; }
            to { height: 120%; top: -10%; }
        }

        .explosion {
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255,255,255,1), rgba(255,255,255,0.5), transparent);
            border-radius: 50%;
            animation: explode-area 0.6s ease-out forwards;
            box-shadow: 0 0 30px rgba(255,255,255,0.8);
        }

        @keyframes explode-area {
            from { transform: scale(0); opacity: 1; }
            to { transform: scale(2); opacity: 0; }
        }

        .particle-system {
            position: absolute;
            pointer-events: none;
            z-index: 150;
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: radial-gradient(circle, rgba(255,255,255,1), rgba(255,255,0,0.8));
            border-radius: 50%;
            animation: particle-burst 0.8s ease-out forwards;
        }

        @keyframes particle-burst {
            0% { 
                transform: scale(1) translate(0, 0); 
                opacity: 1; 
            }
            100% { 
                transform: scale(0.2) translate(var(--dx), var(--dy)); 
                opacity: 0; 
            }
        }

        .score-popup {
            position: absolute;
            font-size: 28px;
            font-weight: bold;
            color: #56ab2f;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            pointer-events: none;
            z-index: 200;
            animation: score-rise 1s ease-out forwards;
        }

        @keyframes score-rise {
            from { transform: translateY(0) scale(0.5); opacity: 1; }
            to { transform: translateY(-80px) scale(1.5); opacity: 0; }
        }

        .combo-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 64px;
            font-weight: bold;
            background: linear-gradient(45deg, #56ab2f, #f39c12);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 300;
            animation: combo-bounce 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes combo-bounce {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-180deg); }
            50% { transform: translate(-50%, -50%) scale(1.5) rotate(0deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); opacity: 0; }
        }

        .game-controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }

        .btn {
            padding: 15px 30px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #56ab2f, #a8e063);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f39c12, #f1c40f);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .game-over-content {
            background: white;
            padding: 50px;
            border-radius: 25px;
            text-align: center;
            animation: slideIn 0.5s ease-out;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        @keyframes slideIn {
            from { transform: translateY(-100px) scale(0.8); opacity: 0; }
            to { transform: translateY(0) scale(1); opacity: 1; }
        }

        .game-over-title {
            font-size: 48px;
            font-weight: bold;
            background: linear-gradient(45deg, #56ab2f, #a8e063);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 30px;
        }

        .final-stats {
            font-size: 24px;
            margin-bottom: 30px;
            line-height: 1.8;
        }

        .final-stats strong {
            color: #56ab2f;
        }

        .high-score {
            font-size: 20px;
            color: #f39c12;
            margin-bottom: 20px;
        }

        .hint-animation {
            animation: hint-pulse 2s ease-in-out infinite;
        }

        @keyframes hint-pulse {
            0%, 100% { 
                transform: scale(1); 
                box-shadow: 0 0 0 rgba(86, 171, 47, 0);
            }
            50% { 
                transform: scale(1.15); 
                box-shadow: 0 0 30px rgba(86, 171, 47, 1);
            }
        }

        .no-moves-shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-10px); }
            75% { transform: translateX(10px); }
        }

        .special-combo-effect {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 500;
            background: radial-gradient(circle at center, transparent, rgba(255,255,255,0.3));
            animation: special-combo-flash 0.5s ease-out;
        }

        @keyframes special-combo-flash {
            from { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; }
            to { opacity: 0; transform: scale(1.5); }
        }

        .processing-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.1);
            z-index: 50;
            display: none;
        }

        .debug-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            display: none;
            z-index: 1001;
        }
    </style>
</head>
<body>
    <div class="game-container" id="gameContainer">
        <div class="game-header">
            <h1 class="game-title">ü•ó Healthy Food Match ü•ó</h1>
        </div>

        <div class="game-stats">
            <div class="stat-box">
                <div class="stat-label">Score</div>
                <div class="stat-value" id="score">0</div>
                <div class="multiplier-indicator" id="multiplier">2x</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Moves Left</div>
                <div class="stat-value" id="moves">30</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Chain</div>
                <div class="stat-value" id="chain">0</div>
            </div>
        </div>

        <div class="special-candies-info">
            <div class="special-candies-title">üåü ‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏û‡∏¥‡πÄ‡∏®‡∏© üåü</div>
            <div class="special-candies-list">
                <div class="special-candy-info">
                    <span>4 ‡∏ä‡∏¥‡πâ‡∏ô</span>
                    <span>‚û°Ô∏è</span>
                    <span style="font-size: 20px;">ü•ï</span>
                    <span>‡∏ú‡∏±‡∏Å‡∏•‡∏≤‡∏¢ (‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡πÅ‡∏ñ‡∏ß/‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå)</span>
                </div>
                <div class="special-candy-info">
                    <span>‡∏£‡∏π‡∏õ L/T</span>
                    <span>‚û°Ô∏è</span>
                    <span style="font-size: 20px;">üéÅ</span>
                    <span>‡∏ã‡∏∏‡∏õ‡πÄ‡∏õ‡∏≠‡∏£‡πå‡∏ü‡∏π‡πâ‡∏î (‡∏£‡∏∞‡πÄ‡∏ö‡∏¥‡∏î 3x3)</span>
                </div>
                <div class="special-candy-info">
                    <span>5 ‡∏ä‡∏¥‡πâ‡∏ô</span>
                    <span>‚û°Ô∏è</span>
                    <span style="font-size: 20px;">üåà</span>
                    <span>‡∏™‡∏•‡∏±‡∏î‡∏£‡∏∏‡πâ‡∏á (‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡∏ä‡∏ô‡∏¥‡∏î‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏Å‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î)</span>
                </div>
            </div>
        </div>

        <div class="board-container">
            <div class="board" id="board"></div>
            <div class="processing-overlay" id="processingOverlay"></div>
        </div>

        <div class="game-controls">
            <button class="btn btn-primary" onclick="game.newGame()">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà</button>
            <button class="btn btn-secondary" onclick="game.showHint()">‡∏ä‡πà‡∏ß‡∏¢‡∏ö‡∏≠‡∏Å‡∏´‡∏ô‡πà‡∏≠‡∏¢ üí°</button>
            <button class="btn btn-secondary" onclick="game.toggleDebug()" id="debugBtn" style="display: none;">Debug</button>
        </div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-content">
            <h2 class="game-over-title">‡∏à‡∏ö‡πÄ‡∏Å‡∏°!</h2>
            <div class="final-stats">
                <strong>‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢:</strong> <span id="finalScore">0</span><br>
                <strong>‡∏Ñ‡∏≠‡∏°‡πÇ‡∏ö‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î:</strong> <span id="maxCombo">0</span>x<br>
                <strong>‡∏≠‡∏≤‡∏´‡∏≤‡∏£‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏ó‡∏µ‡πà‡∏™‡∏£‡πâ‡∏≤‡∏á:</strong> <span id="specialCreated">0</span> ‡∏ä‡∏¥‡πâ‡∏ô<br>
                <strong>‡πÄ‡∏ä‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î:</strong> <span id="maxChain">0</span>
            </div>
            <div class="high-score" id="highScoreText"></div>
            <button class="btn btn-primary" onclick="game.newGame()">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
        </div>
    </div>

    <div class="debug-info" id="debugInfo">
        <div>FPS: <span id="fps">60</span></div>
        <div>State: <span id="gameState">idle</span></div>
        <div>Processing: <span id="processingState">false</span></div>
        <div>Queue: <span id="queueLength">0</span></div>
    </div>

 ```html
<script>
/*
SUGGESTED CSS ADDITIONS for Drag-and-Drop:
Please add these styles to your <style> tag in the HTML for the best visual experience.

.candy.dragging {
    position: relative;
    z-index: 100;
    transform: scale(1.2);
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    transition: none; // Disable transition during drag for instant feedback
}
*/

class CandyCrush {
    constructor() {
        // --- Game State ---
        this.board = [];
        this.size = 8;
        this.score = 0;
        this.moves = 30;
        this.combo = 0;
        this.maxCombo = 0;
        this.specialCandiesCreated = 0;
        this.highScore = localStorage.getItem('healthyFoodMatchHighScore') || 0;

        // --- Core Mechanics ---
        this.candyTypes = ['ü•ï', 'ü•¶', 'üçé', 'üçä', 'ü•í', 'üçá'];
        this.specialCandies = new Map();

        // --- UI & Control ---
        this.isProcessing = false;
        this.hintTimeout = null;

        // --- Drag & Drop State ---
        this.draggedCell = null;
        this.startPos = { x: 0, y: 0 };
        this.isDragging = false;

        // --- DOM Elements ---
        this.boardElement = document.getElementById('board');
        this.scoreElement = document.getElementById('score');
        this.movesElement = document.getElementById('moves');
        this.gameOverOverlay = document.getElementById('gameOverOverlay');
        
        this.init();
    }

    // ========================================================================
    // INITIALIZATION & GAME SETUP
    // ========================================================================

    init() {
        this.isProcessing = true;
        this.createBoardModel();
        this.createBoardView();
        
        while (!this.hasPossibleMoves()) {
            this.createBoardModel();
        }
        
        this.renderAll();
        this.updateUI();
        this.isProcessing = false;
    }

    createBoardModel() {
        this.board = [];
        this.specialCandies.clear();
        for (let r = 0; r < this.size; r++) {
            this.board[r] = [];
            for (let c = 0; c < this.size; c++) {
                let candy;
                do {
                    candy = this.getRandomCandy();
                } while (
                    (c >= 2 && this.board[r][c - 1] === candy && this.board[r][c - 2] === candy) ||
                    (r >= 2 && this.board[r - 2][c] === candy && this.board[r - 1][c] === candy)
                );
                this.board[r][c] = candy;
            }
        }
    }

    createBoardView() {
        this.boardElement.innerHTML = '';
        for (let r = 0; r < this.size; r++) {
            for (let c = 0; c < this.size; c++) {
                const cell = document.createElement('div');
                cell.className = 'cell';
                cell.dataset.row = r;
                cell.dataset.col = c;
                
                // Add event listeners for drag-and-drop
                cell.addEventListener('mousedown', (e) => this.onDragStart(e, r, c));
                cell.addEventListener('touchstart', (e) => this.onDragStart(e, r, c));
                
                this.boardElement.appendChild(cell);
            }
        }
        // Add global listeners for drag end
        window.addEventListener('mouseup', (e) => this.onDragEnd(e));
        window.addEventListener('touchend', (e) => this.onDragEnd(e));
        window.addEventListener('mousemove', (e) => this.onDragMove(e));
        window.addEventListener('touchmove', (e) => this.onDragMove(e));
    }

    newGame() {
        this.score = 0;
        this.moves = 30;
        this.combo = 0;
        this.maxCombo = 0;
        this.specialCandiesCreated = 0;
        
        this.gameOverOverlay.style.display = 'none';
        this.init();
    }

    // ========================================================================
    // RENDERING & UI UPDATES
    // ========================================================================

    renderAll() {
        for (let r = 0; r < this.size; r++) {
            for (let c = 0; c < this.size; c++) {
                this.renderCell(r, c);
            }
        }
    }
    
    renderCell(row, col, options = {}) {
        const cell = this.getCellElement(row, col);
        if (!cell) return;

        // Reset transform style from dragging
        cell.style.transform = '';

        const candy = this.board[row][col];
        if (!candy) {
            cell.innerHTML = '';
            return;
        }

        const candyElement = document.createElement('span');
        candyElement.className = 'candy';
        candyElement.textContent = candy;

        const specialType = this.specialCandies.get(`${row},${col}`);
        if (specialType) {
            candyElement.classList.add(specialType);
            if (specialType === 'color-bomb') candyElement.textContent = 'üåà';
            if (specialType === 'wrapped') candyElement.textContent = 'ü•ë';
        }

        if (options.fall) {
            candyElement.classList.add('falling');
        }

        cell.innerHTML = '';
        cell.appendChild(candyElement);
    }

    updateUI() {
        this.scoreElement.textContent = this.score;
        this.movesElement.textContent = this.moves;
    }

    // ========================================================================
    // USER INTERACTION (DRAG & DROP)
    // ========================================================================
    
    onDragStart(event, row, col) {
        if (this.isProcessing || this.moves <= 0 || this.isDragging) return;
        event.preventDefault();
        this.clearHint();

        this.isDragging = true;
        this.draggedCell = { row, col, element: event.currentTarget.querySelector('.candy') };
        
        if (this.draggedCell.element) {
            this.draggedCell.element.classList.add('dragging');
        }

        const touch = event.touches ? event.touches[0] : event;
        this.startPos = { x: touch.clientX, y: touch.clientY };
    }

    onDragMove(event) {
        if (!this.isDragging || !this.draggedCell || !this.draggedCell.element) return;
        event.preventDefault();

        const touch = event.touches ? event.touches[0] : event;
        const dx = touch.clientX - this.startPos.x;
        const dy = touch.clientY - this.startPos.y;

        this.draggedCell.element.style.transform = `translate(${dx}px, ${dy}px) scale(1.2)`;
    }

    onDragEnd(event) {
        if (!this.isDragging || !this.draggedCell) return;
        this.isDragging = false;

        if (this.draggedCell.element) {
            this.draggedCell.element.classList.remove('dragging');
            this.draggedCell.element.style.transform = ''; // Reset style
        }
        
        const touch = event.changedTouches ? event.changedTouches[0] : event;
        const endPos = { x: touch.clientX, y: touch.clientY };
        
        const dx = endPos.x - this.startPos.x;
        const dy = endPos.y - this.startPos.y;
        
        const dragThreshold = 20; // Minimum pixels to count as a drag
        
        if (Math.abs(dx) > dragThreshold || Math.abs(dy) > dragThreshold) {
            let targetRow = this.draggedCell.row;
            let targetCol = this.draggedCell.col;

            if (Math.abs(dx) > Math.abs(dy)) {
                // Horizontal drag
                targetCol += (dx > 0) ? 1 : -1;
            } else {
                // Vertical drag
                targetRow += (dy > 0) ? 1 : -1;
            }

            if (this.isValid(targetRow, targetCol)) {
                this.handleSwap(this.draggedCell.row, this.draggedCell.col, targetRow, targetCol);
            }
        }
        
        this.draggedCell = null;
    }

    async handleSwap(r1, c1, r2, c2) {
        this.isProcessing = true;
        
        await this.animateSwap(r1, c1, r2, c2);

        const specialType1 = this.specialCandies.get(`${r1},${c1}`);
        const specialType2 = this.specialCandies.get(`${r2},${c2}`);

        if (specialType1 && specialType2) {
            this.moves--;
            this.updateUI();
            await this.triggerSpecialCombo(r1, c1, r2, c2, specialType1, specialType2);
            await this.processBoard();
        } else {
            const matches = this.findAllMatches();
            if (matches.length > 0) {
                this.moves--;
                this.updateUI();
                await this.processBoard();
            } else {
                await this.animateSwap(r1, c1, r2, c2); // Animate the reversal
            }
        }

        this.isProcessing = false;
        this.checkGameStatus();
    }

    // ========================================================================
    // CORE GAME LOGIC
    // ========================================================================

    async processBoard() {
        this.combo = 0;
        let matches = this.findAllMatches();

        while (matches.length > 0) {
            this.isProcessing = true;
            this.combo++;
            if (this.combo > this.maxCombo) this.maxCombo = this.combo;
            if (this.combo > 1) this.showComboText(`${this.combo}x COMBO!`);

            const { cellsToClear, specialCreations } = this.processFoundMatches(matches);

            await this.clearAndScore(cellsToClear);
            await this.createSpecialCandies(specialCreations);
            await this.delay(150);

            await this.applyGravity();
            await this.fillNewCandies();
            
            await this.delay(300);
            matches = this.findAllMatches();
        }
        
        if (!this.hasPossibleMoves()) {
            await this.shuffleBoard();
        }
    }
    
    processFoundMatches(matches) {
        const cellsToClear = new Set();
        const specialCreations = [];
        let specialCandiesToTrigger = [];

        for (const match of matches) {
            let specialCreated = false;
            if (match.type === 'five') {
                specialCreations.push({ r: match.r, c: match.c, type: 'color-bomb' });
                specialCreated = true;
            } else if (match.type === 'L' || match.type === 'T') {
                specialCreations.push({ r: match.r, c: match.c, type: 'wrapped' });
                specialCreated = true;
            } else if (match.type === 'four') {
                specialCreations.push({ r: match.r, c: match.c, type: match.orientation === 'h' ? 'striped-v' : 'striped-h' });
                specialCreated = true;
            }

            for (const { r, c } of match.cells) {
                const key = `${r},${c}`;
                if (specialCreated && r === match.r && c === match.c) continue;
                
                cellsToClear.add(key);
                if (this.specialCandies.has(key)) {
                    specialCandiesToTrigger.push({r, c, type: this.specialCandies.get(key)});
                }
            }
        }
        
        while (specialCandiesToTrigger.length > 0) {
            const {r, c, type} = specialCandiesToTrigger.pop();
            const affectedCells = this.getAffectedCellsForSpecial(r, c, type);
            
            for (const {r: ar, c: ac} of affectedCells) {
                const key = `${ar},${ac}`;
                if (!cellsToClear.has(key)) {
                    cellsToClear.add(key);
                    if (this.specialCandies.has(key)) {
                        specialCandiesToTrigger.push({r: ar, c: ac, type: this.specialCandies.get(key)});
                    }
                }
            }
        }
        
        return { cellsToClear, specialCreations };
    }

    findAllMatches() {
        const allMatches = [];
        const checked = new Set();

        for (let r = 0; r < this.size; r++) {
            for (let c = 0; c < this.size; c++) {
                const key = `${r},${c}`;
                if (checked.has(key) || !this.board[r][c]) continue;

                const candy = this.board[r][c];
                const hMatch = this.getMatch(r, c, 0, 1, candy);
                const vMatch = this.getMatch(r, c, 1, 0, candy);

                const hCells = hMatch.length >= 3 ? hMatch : [];
                const vCells = vMatch.length >= 3 ? vMatch : [];

                if (hCells.length > 0 && vCells.length > 0) {
                    const combined = [...new Set([...hCells, ...vCells])].map(cellKey => {
                        const [r, c] = cellKey.split(',').map(Number);
                        return {r, c};
                    });
                     // T or L shape logic needs to be more robust. Let's simplify.
                    const intersection = hCells.filter(hc => vCells.some(vc => vc.r === hc.r && vc.c === hc.c));
                    if(intersection.length > 0){
                        const allCells = [...new Set([...hCells, ...vCells])];
                        allMatches.push({ type: allCells.length >= 5 ? 'T' : 'L', r: intersection[0].r, c: intersection[0].c, cells: allCells });
                        allCells.forEach(cell => checked.add(`${cell.r},${cell.c}`));
                    }

                } else if (hCells.length > 0) {
                    const type = hCells.length === 5 ? 'five' : hCells.length === 4 ? 'four' : 'three';
                    allMatches.push({ type, r, c: hCells[Math.floor(hCells.length / 2)].c, cells: hCells, orientation: 'h' });
                    hCells.forEach(cell => checked.add(`${cell.r},${cell.c}`));
                } else if (vCells.length > 0) {
                    const type = vCells.length === 5 ? 'five' : vCells.length === 4 ? 'four' : 'three';
                    allMatches.push({ type, r: vCells[Math.floor(vCells.length / 2)].r, c, cells: vCells, orientation: 'v' });
                    vCells.forEach(cell => checked.add(`${cell.r},${cell.c}`));
                }
            }
        }
        return allMatches;
    }

    getMatch(r, c, dr, dc, candy) {
        const match = [];
        let cr = r, cc = c;
        while (this.isValid(cr, cc) && this.board[cr][cc] === candy) {
            match.push({ r: cr, c: cc });
            cr += dr;
            cc += dc;
        }
        return match;
    }

    async clearAndScore(cellsToClear) {
        let points = 0;
        for (const key of cellsToClear) {
            const [r, c] = key.split(',').map(Number);
            if (this.board[r][c]) {
                this.animateMatch(r, c);
                this.board[r][c] = null;
                this.specialCandies.delete(key);
                points += 10 * this.combo;
            }
        }
        this.score += points;
        if (points > 0) this.showScorePopup(points);
        this.updateUI();
        await this.delay(500);
    }

    async createSpecialCandies(creations) {
        for (const special of creations) {
            this.specialCandies.set(`${special.r},${special.c}`, special.type);
            this.board[special.r][special.c] = this.getRandomCandy();
            this.renderCell(special.r, special.c);
            this.specialCandiesCreated++;
        }
    }
    
    async applyGravity() {
        for (let c = 0; c < this.size; c++) {
            let emptyRow = this.size - 1;
            for (let r = this.size - 1; r >= 0; r--) {
                if (this.board[r][c]) {
                    if (r !== emptyRow) {
                        this.board[emptyRow][c] = this.board[r][c];
                        this.board[r][c] = null;
                        
                        const oldKey = `${r},${c}`;
                        const newKey = `${emptyRow},${c}`;
                        if (this.specialCandies.has(oldKey)) {
                            this.specialCandies.set(newKey, this.specialCandies.get(oldKey));
                            this.specialCandies.delete(oldKey);
                        }
                    }
                    emptyRow--;
                }
            }
        }
        this.renderAll();
    }

    async fillNewCandies() {
        for (let c = 0; c < this.size; c++) {
            for (let r = 0; r < this.size; r++) {
                if (!this.board[r][c]) {
                    this.board[r][c] = this.getRandomCandy();
                    this.renderCell(r, c, { fall: true });
                }
            }
        }
    }

    // ========================================================================
    // SPECIAL CANDY LOGIC
    // ========================================================================

    async triggerSpecialCombo(r1, c1, r2, c2, type1, type2) {
        this.createSpecialEffect('special-combo-flash', r1, c1);
        const cellsToClear = new Set([`${r1},${c1}`, `${r2},${c2}`]);
        const comboTypes = [type1, type2].sort().join(',');

        if (comboTypes.includes('color-bomb,color-bomb')) {
            for (let r = 0; r < this.size; r++) for (let c = 0; c < this.size; c++) cellsToClear.add(`${r},${c}`);
            this.showComboText('ULTRA CLEAR!');
        } else if (comboTypes.includes('color-bomb') && comboTypes.includes('striped')) {
            const otherCandy = this.board[type1 === 'color-bomb' ? r2 : r1][type1 === 'color-bomb' ? c2 : c1];
            for (let r = 0; r < this.size; r++) {
                for (let c = 0; c < this.size; c++) {
                    if (this.board[r][c] === otherCandy) {
                        const newType = Math.random() > 0.5 ? 'striped-h' : 'striped-v';
                        this.getAffectedCellsForSpecial(r, c, newType).forEach(cell => cellsToClear.add(`${cell.r},${cell.c}`));
                    }
                }
            }
            this.showComboText('STRIPE POWER!');
        } else if (comboTypes.includes('color-bomb') && comboTypes.includes('wrapped')) {
            const otherCandy = this.board[type1 === 'color-bomb' ? r2 : r1][type1 === 'color-bomb' ? c2 : c1];
            const secondCandy = this.getRandomCandy();
            for (let r = 0; r < this.size; r++) {
                for (let c = 0; c < this.size; c++) {
                    if (this.board[r][c] === otherCandy || this.board[r][c] === secondCandy) {
                        cellsToClear.add(`${r},${c}`);
                    }
                }
            }
            this.showComboText('DOUBLE BOOM!');
        } else if (comboTypes.includes('wrapped,wrapped')) {
            this.getAffectedCellsForSpecial(r1, c1, 'wrapped', 2).forEach(cell => cellsToClear.add(`${cell.r},${cell.c}`));
            this.showComboText('MEGA BOOM!');
        } else if (comboTypes.includes('striped') && comboTypes.includes('wrapped')) {
            this.getAffectedCellsForSpecial(r1, c1, 'striped-h', 1).forEach(cell => cellsToClear.add(`${cell.r},${cell.c}`));
            this.getAffectedCellsForSpecial(r1, c1, 'striped-v', 1).forEach(cell => cellsToClear.add(`${cell.r},${cell.c}`));
            this.showComboText('CROSS BLAST!');
        } else if (comboTypes.includes('striped-h') && comboTypes.includes('striped-v')) {
            this.getAffectedCellsForSpecial(r1, c1, 'striped-h').forEach(cell => cellsToClear.add(`${cell.r},${cell.c}`));
            this.getAffectedCellsForSpecial(r1, c1, 'striped-v').forEach(cell => cellsToClear.add(`${cell.r},${cell.c}`));
            this.showComboText('LINE BLAST!');
        }
        
        await this.clearAndScore(cellsToClear);
    }

    getAffectedCellsForSpecial(r, c, type, radius = 1) {
        const affected = [];
        if (type.includes('striped-h')) {
            this.createLineEffect(r, c, 'horizontal');
            for(let i = -radius; i <= radius; i++) {
                for (let col = 0; col < this.size; col++) affected.push({ r: r + i, c: col });
            }
        }
        if (type.includes('striped-v')) {
            this.createLineEffect(r, c, 'vertical');
            for(let i = -radius; i <= radius; i++) {
                for (let row = 0; row < this.size; row++) affected.push({ r: row, c: c + i });
            }
        }
        if (type.includes('wrapped')) {
            this.createExplosionEffect(r, c);
            for (let row = r - radius; row <= r + radius; row++) {
                for (let col = c - radius; col <= c + radius; col++) {
                    affected.push({ r: row, c: col });
                }
            }
        }
        return affected.filter(cell => this.isValid(cell.r, cell.c));
    }

    // ========================================================================
    // MOVE VALIDATION & HINTS
    // ========================================================================
    
    hasPossibleMoves() {
        for (let r = 0; r < this.size; r++) {
            for (let c = 0; c < this.size; c++) {
                if (c < this.size - 1 && this.isMoveValid(r, c, r, c + 1)) return true;
                if (r < this.size - 1 && this.isMoveValid(r, c, r + 1, c)) return true;
            }
        }
        return false;
    }
    
    isMoveValid(r1, c1, r2, c2) {
        this.swapModel(r1, c1, r2, c2);
        const hasMatch = this.findAllMatches().length > 0;
        this.swapModel(r1, c1, r2, c2);
        return hasMatch;
    }
    
    showHint() {
        if (this.isProcessing) return;
        this.clearHint();

        for (let r = 0; r < this.size; r++) {
            for (let c = 0; c < this.size; c++) {
                if (c < this.size - 1 && this.isMoveValid(r, c, r, c + 1)) {
                    this.animateHint(r, c, r, c + 1);
                    return;
                }
                if (r < this.size - 1 && this.isMoveValid(r, c, r + 1, c)) {
                    this.animateHint(r, c, r + 1, c);
                    return;
                }
            }
        }
    }

    animateHint(r1, c1, r2, c2) {
        const cell1 = this.getCellElement(r1, c1);
        const cell2 = this.getCellElement(r2, c2);
        cell1.classList.add('hint-animation');
        cell2.classList.add('hint-animation');
        this.hintTimeout = setTimeout(() => this.clearHint(), 2000);
    }

    clearHint() {
        if (this.hintTimeout) clearTimeout(this.hintTimeout);
        document.querySelectorAll('.hint-animation').forEach(el => el.classList.remove('hint-animation'));
    }

    async shuffleBoard() {
        this.isProcessing = true;
        this.boardElement.classList.add('no-moves-shake');
        this.showComboText('SHUFFLING!');
        await this.delay(500);

        do {
            const allCandies = this.board.flat();
            for (let i = allCandies.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allCandies[i], allCandies[j]] = [allCandies[j], allCandies[i]];
            }
            for (let r = 0; r < this.size; r++) {
                for (let c = 0; c < this.size; c++) {
                    this.board[r][c] = allCandies[r * this.size + c];
                }
            }
        } while (this.findAllMatches().length > 0 || !this.hasPossibleMoves());

        this.renderAll();
        await this.delay(500);
        this.boardElement.classList.remove('no-moves-shake');
        this.isProcessing = false;
    }

    // ========================================================================
    // GAME STATE CHECKS
    // ========================================================================

    checkGameStatus() {
        if (this.moves <= 0) {
            this.isProcessing = true;
            this.showGameOver();
        }
    }

    showGameOver() {
        document.getElementById('finalScore').textContent = this.score;
        document.getElementById('maxCombo').textContent = this.maxCombo;
        document.getElementById('specialCreated').textContent = this.specialCandiesCreated;
        const highScoreText = document.getElementById('highScoreText');
        
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('healthyFoodMatchHighScore', this.highScore);
            highScoreText.textContent = 'üéâ ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÉ‡∏´‡∏°‡πà! üéâ';
            highScoreText.style.color = '#f39c12';
        } else {
            highScoreText.textContent = `‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î: ${this.highScore}`;
            highScoreText.style.color = '#56ab2f';
        }
        
        this.gameOverOverlay.style.display = 'flex';
    }

    // ========================================================================
    // ANIMATIONS & EFFECTS
    // ========================================================================

    async animateSwap(r1, c1, r2, c2) {
        this.swapModel(r1, c1, r2, c2);
        this.renderCell(r1, c1);
        this.renderCell(r2, c2);
        await this.delay(300);
    }

    animateMatch(r, c) {
        const candy = this.getCellElement(r, c)?.querySelector('.candy');
        if (candy) candy.classList.add('matched');
    }

    showScorePopup(score) {
        const popup = document.createElement('div');
        popup.className = 'score-popup';
        popup.textContent = `+${score}`;
        popup.style.left = `${Math.random() * 80 + 10}%`;
        popup.style.top = `${Math.random() * 80 + 10}%`;
        this.boardElement.appendChild(popup);
        setTimeout(() => popup.remove(), 1000);
    }

    showComboText(text) {
        const comboText = document.createElement('div');
        comboText.className = 'combo-text';
        comboText.textContent = text;
        this.boardElement.appendChild(comboText);
        setTimeout(() => comboText.remove(), 1200);
    }

    createLineEffect(r, c, direction) {
        const effect = document.createElement('div');
        effect.className = `special-effect line-clear-${direction === 'horizontal' ? 'h' : 'v'}`;
        const cellRect = this.getCellElement(r, c).getBoundingClientRect();
        const boardRect = this.boardElement.getBoundingClientRect();
        
        if (direction === 'horizontal') {
            effect.style.top = `${cellRect.top - boardRect.top}px`;
            effect.style.left = `0`;
        } else {
            effect.style.left = `${cellRect.left - boardRect.left}px`;
            effect.style.top = `0`;
        }
        this.boardElement.appendChild(effect);
        setTimeout(() => effect.remove(), 500);
    }

    createExplosionEffect(r, c) {
        const effect = document.createElement('div');
        effect.className = 'special-effect explosion';
        const cellRect = this.getCellElement(r, c).getBoundingClientRect();
        const boardRect = this.boardElement.getBoundingClientRect();
        effect.style.left = `${cellRect.left - boardRect.left - (200 - 65) / 2}px`;
        effect.style.top = `${cellRect.top - boardRect.top - (200 - 65) / 2}px`;
        this.boardElement.appendChild(effect);
        setTimeout(() => effect.remove(), 600);
    }

    createSpecialEffect(className, r, c) {
        const effect = document.createElement('div');
        effect.className = `special-effect ${className}`;
        const cellRect = this.getCellElement(r, c).getBoundingClientRect();
        const boardRect = this.boardElement.getBoundingClientRect();
        effect.style.left = `${cellRect.left - boardRect.left}px`;
        effect.style.top = `${cellRect.top - boardRect.top}px`;
        this.boardElement.appendChild(effect);
        setTimeout(() => effect.remove(), 500);
    }

    // ========================================================================
    // UTILITY HELPERS
    // ========================================================================

    getRandomCandy() {
        return this.candyTypes[Math.floor(Math.random() * this.candyTypes.length)];
    }

    swapModel(r1, c1, r2, c2) {
        [this.board[r1][c1], this.board[r2][c2]] = [this.board[r2][c2], this.board[r1][c1]];
        
        const key1 = `${r1},${c1}`, key2 = `${r2},${c2}`;
        const special1 = this.specialCandies.get(key1);
        const special2 = this.specialCandies.get(key2);
        
        if (special1) this.specialCandies.set(key2, special1); else this.specialCandies.delete(key2);
        if (special2) this.specialCandies.set(key1, special2); else this.specialCandies.delete(key1);
    }

    isAdjacent(r1, c1, r2, c2) {
        return Math.abs(r1 - r2) + Math.abs(c1 - c2) === 1;
    }
    
    isValid(r, c) {
        return r >= 0 && r < this.size && c >= 0 && c < this.size;
    }

    getCellElement(row, col) {
        return this.boardElement.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    }

    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

window.addEventListener('DOMContentLoaded', () => {
    const game = new CandyCrush();
    window.game = game;
});


</script>


</body>
</html>
